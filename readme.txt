# PS-PL SHAKE算法数据通路验证项目

本项目旨在搭建并验证一个Zynq SoC中ARM处理器（PS）与FPGA（PL）之间的数据通路。项目的最终目标是使用PL来加速SHAKE加密算法，当前阶段专注于打通数据流，为后续的硬件IP集成做准备。

## 1. 核心目标

将一个纯软件实现的SHAKE加密算法（来自`ps_shake`项目）的部分计算任务迁移到PL端。当前的核心任务是：

1.  数据拦截：在PS端运行`ps_shake`的C代码时，从其核心算法中精确“拦截”将要被处理的1600位（200字节）`state`数据。
2.  建立数据通路：将这份`state`数据通过AXI总线从PS发送到PL端的BRAM中。
3.  实现灵活传输：确保数据传输的软件框架是通用的，能够处理可变长度的数据，而不仅仅是固定的1600位。PS需要将输入数据、输入长度、期望输出长度这三个可变的信息都传递给PL。
4.  硬件验证：使用Vivado的ILA（集成逻辑分析仪）工具，在硬件层面捕获信号，以验证数据已正确写入BRAM，并且PL端的IP能够正确读取。

## 2. 项目架构

本项目基于 `pspl` 硬件平台，其核心架构为：

 PS (Processing System)：作为主控，负责：
     运行`ps_shake`算法代码并准备输入数据。
     通过 AXI-Lite 接口，向PL端的控制IP (`pl_bram_rd`) 发送控制命令，包括数据长度和启动信号。
     通过 AXI 接口，经由`AXI BRAM Controller`，将数据写入到共享的`Block Memory` (BRAM) 中。
     从BRAM中读回PL的处理结果（在当前验证阶段，是读回写入的数据进行校验）。

 PL (Programmable Logic)：作为从设备/加速器，负责：
     包含一个自定义IP `pl_bram_rd`，用于接收PS的控制命令。
     根据PS的指令，从BRAM中读取指定长度的数据。
     （未来）将读取的数据送入SHAKE硬件加速核进行计算。
     （未来）将计算结果写回到BRAM的指定位置。

## 3. 实施步骤

### 3.1 软件修改 (Vitis)

1.  代码合并：将`ps_shake`项目的所有`.c`和`.h`源文件复制到`pspl`项目的Vitis工程`src`目录下。
2.  数据拦截：修改`ps_shake`的底层文件 `fips202.c`。
     在`shake256_absorb`函数（该函数负责更新SHAKE算法的1600位内部状态）的末尾，添加`memcpy`语句，将最终准备好的`state`数组（在函数中名为`s`，大小为200字节）复制到一个全局变量`shake_input_state_to_pl`中。
3.  构建通用框架：重写`main.c`文件，核心是创建一个通用的数据发送与验证函数`send_and_verify_data`。
     该函数接收`数据指针`、`输入长度`和`输出长度`作为参数。
     函数内部，通过`PL_BRAM_RD_mWriteReg`将长度变量写入`pl_bram_rd` IP的控制寄存器。
     通过`Xil_Out8`将指定长度的数据逐字节写入BRAM。
     `main`函数中调用此通用函数来发送拦截到的1600位`state`数据，并额外发送一个自定义长度的数据阵列，以证明框架的灵活性。
4.  问题排查：
     编译错误：删除了`ps_shake`中自带的测试文件（如`src/test/fors.c`），解决了`main`函数重复定义的错误。
     链接错误：删除了所有与非SHAKE算法（如Haraka, SHA2）相关的`.c`和`.h`文件，解决了因缺少编译宏定义而导致的`undefined reference`链接错误。

### 3.2 硬件验证 (Vivado)

项目中采用了两种ILA调试方案来验证数据通路的不同部分：

1.  验证 PS -> BRAM 写通路 (不启动PL)：
     ILA探针：连接到`axi_bram_ctrl_0`的`S_AXI`接口。
     监控信号：`S_AXI_AWADDR` (写地址), `S_AXI_WDATA` (写数据), `S_AXI_WVALID` (写数据有效)。
     触发条件：`S_AXI_WVALID`的上升沿 (`R`)。
     正确结果：ILA捕获到波形，显示地址从`0x40000000`开始递增，且数据与`main.c`中发送的`state`一致。这证明PS已成功将数据写入BRAM。

2.  验证 BRAM -> PL 读通路 (需启动PL)：
     ILA探针：连接到`blk_mem_gen_0`模块B端口的内部信号。
     监控信号：`addrb` (B端口读地址), `doutb` (B端口读数据), `enb` (B端口使能)。
     触发条件：`enb`的上升沿 (`R`)。
     正确结果：在PS通过`main.c`中的代码启动PL后，ILA捕获到波形，显示`enb`为高，`addrb`从0开始递增，`doutb`在一个时钟周期延迟后，依次输出与写入BRAM完全一致的数据。这证明PL端的IP已成功从BRAM读出数据。

## 4. 当前状态

 软件代码已完成合并和修改，并通过编译，生成了可执行的 `ps_pl_bram.elf` 文件。
 硬件设计已添加ILA并生成了包含调试逻辑的Bitstream。
 项目已准备就绪，可以在硬件开发板上进行最终的ILA波形捕获和验证。
 项目已配置`.gitignore`文件，可随时上传到GitHub进行版本管理。



你好，我需要你协助我完成一个Zynq SoC的软硬件协同设计项目。请仔细阅读以下背景信息，以便快速理解我的需求：

项目总体目标：
我正在将一个纯软件实现的SHAKE加密算法（来源于一个名为 ps_shake 的GitHub项目）移植到FPGA上进行硬件加速。我目前处于数据通路验证阶段。

项目所用平台：
我使用一个名为 pspl 的基础Zynq工程。这个工程的硬件架构是：PS通过AXI BRAM控制器，将数据写入PL端的BRAM中；同时，PL端有一个自定义IP (pl_bram_rd)，它可以通过AXI-Lite接口接收PS的指令，并从BRAM中读取数据。

我当前已完成的工作：

代码合并：我已经将ps_shake的所有C源代码，与pspl的Vitis软件工程合并。

数据拦截：我修改了ps_shake的核心文件fips202.c，在shake256_absorb函数中成功拦截到了1600位的state数据，并存放在一个全局数组中。

通用软件框架：我重写了main.c，实现了一个可以发送任意长度数据到BRAM的通用函数。这个函数会将数据长度这个变量通过AXI-Lite寄存器写入PL的控制IP，然后再将数据本身写入BRAM。

软件编译：整个Vitis项目已经解决了所有编译和链接错误，可以成功生成.elf文件。

我的核心需求：
我希望你作为我的助手，能够基于以上背景，帮助我进行后续的硬件验证和项目管理工作。具体可能包括：

指导我在Vivado中如何操作ILA来捕获和分析信号，以验证数据通路的正确性。

帮我分析ILA波形，判断结果是否符合预期。

帮我解决在硬件调试中可能遇到的新问题。

帮我整理和管理项目文件，例如上传到GitHub。

现在，我的第一个问题是：我已经编译好了软件，下一步就是在Vivado中进行ILA的硬件调试。请一步步指导我如何操作，以验证PS确实将数据成功写入了BRAM。